#!/usr/bin/env groovy

systems_x86_64 = ['ubuntu-22.04','ubuntu-20.04','ubuntu-18.04','alpine-3.17','alpine-3.16','alpine-3.15','debian-11','debian-10','fedora-36','opensuse-15.4','photon-40','zephyr-2.3','clearlinux','azuresphere-15','yocto-riscv'] as String[]
systems_arm64 = ['ubuntu-22.04','ubuntu-20.04','ubuntu-18.04','alpine-3.17','alpine-3.16','alpine-3.15','debian-11','debian-10','fedora-36','opensuse-15.4','photon-40'] as String[]
systems_arm32 = ['ubuntu-22.04','ubuntu-20.04','ubuntu-18.04','alpine-3.17','alpine-3.16','alpine-3.15','debian-11','debian-10','opensuse-15.4'] as String[]
systems_x86 = ['alpine-3.17','alpine-3.16','alpine-3.15','debian-11','debian-10']
targets = ['x86_64','arm64','arm32','x86'] as String[]
arch_system_map = [x86_64: systems_x86_64, arm64: systems_arm64, arm32: systems_arm32, x86: systems_x86]
releaseType = ['None':'dev', 'Release':'release', 'Development':'dev']

def checkoutStage (arch)
{
  currentBuild.displayName = "IOT ${env.BUILD_ID}"
  cleanWs (cleanWhenAborted: true, cleanWhenFailure: true, cleanWhenNotBuilt: true, cleanWhenSuccess: true)
  checkout scm
}

def buildStage (systems, arch)
{
  def sys = getSystemParam ()
  def board = getTargetParam ()
  def nat = getNativeParam ()
  def sq = getSonarQubeParam ()
  def sonar = 'false'

  if (("${sq}" == 'true' || env.BRANCH_NAME.startsWith ('PR')) && ("${sys}" == 'ubuntu-22.04') && ("${arch}" == 'x86_64'))
  {
    sonar = 'true'
  }

  for (int i = 0; i < systems.size(); ++i)
  {
    def system = systems[i]
    if ("${sys}" == "${system}" || "${sys}" == 'all')
    {
      withCredentials ([
        file (credentialsId: 'AlpinePackagerRSAPrivateKey', variable: 'AlpinePackagerRSAPrivateKey'),
        file (credentialsId: 'AlpinePackagerRSAPublicKey', variable: 'AlpinePackagerRSAPublicKey')
      ])
      {
        sh (script: "./scripts/auth.sh ${system} ${sonar}")
      }
      if ("${nat}" == 'true')
      {
        sh (script: "./scripts/wrapper.sh ./scripts/linux.sh -utest")
      }
      else
      {
        if ("${sonar}" == 'true')
        {
          withSonarQubeEnv (credentialsId: 'ebe4f605-efe9-43ef-b388-607050ee29ce')
          {
            sh (script: "./scripts/docker.sh ${system} ${arch} ${board} ${sonar} ${env.BRANCH_NAME}")
            sh (script: "mv ${arch}/${sys}/lcov/sonar/report-task.txt .")
          }
          timeout (time: 5, unit: 'MINUTES')
          {
            def qg = waitForQualityGate ()
            if (qg.status != 'OK')
            {
              error "Pipeline aborted due to quality gate failure: ${qg.status}"
            }
          }
        }
        else
        {
          sh (script: "./scripts/docker.sh ${system} ${arch} ${board} ${sonar} ${env.BRANCH_NAME}")
        }
      }
    }
  }
}

def metricsStage (systems, arch)
{
  def sys = getSystemParam ()
  def archive = getArchiveParam ()
  publishCoreMetrics (systems, arch)
  if ("${sys}" == 'ubuntu-22.04' || "${sys}" == 'all')
  {
    publishAdvancedMetrics ('ubuntu-22.04', arch)
  }
  if ("${archive}" == 'Release')
  {
    publishQuality (systems, arch);
  }
}

def archiveStage (arch)
{
  def archive = getArchiveParam ()
  if ("${archive}" != 'None')
  {
    publishTars (arch)
    publishDebs (arch)
    publishApks (arch)
    publishRpms (arch)
  }
}

def publishToArtifactory (system, arch, ver, pat)
{
  def uploadSpec = """{"files":[
  {
    "pattern": "${arch}/${system}/${pat}",
    "target": "quality/iot/${ver}/${system}/",
    "props": "distribution=${system};architecture=${arch}"
  }]}"""
  rtUpload (serverId: 'artifactory', spec: "${uploadSpec}")
}

def publishQuality (systems, arch)
{
  def sys = getSystemParam ()
  def vers = sh (script: "cat ./VERSION", returnStdout: true)
  def ver = vers.trim ()
  for (int i = 0; i < systems.size(); ++i)
  {
    if ("${sys}" == "${systems[i]}" || "${sys}" == 'all')
    {
      def system = systems[i]
      publishToArtifactory (system, arch, ver, 'release/release.log')
      publishToArtifactory (system, arch, ver, 'debug/debug.log')
      publishToArtifactory (system, arch, ver, 'release/junit-Results.xml')
    }
  }
}

def publishMetric (file)
{
  if (fileExists (file))
  {
    archiveArtifacts (artifacts: file)
  }
}

def publishCoreMetrics (systems, arch)
{
  def sys = getSystemParam ()
  for (int i = 0; i < systems.size(); ++i)
  {
    if ("${sys}" == "${systems[i]}" || "${sys}" == 'all')
    {
      publishMetric ("${arch}/${systems[i]}/release/release.log")
      publishMetric ("${arch}/${systems[i]}/debug/debug.log")
      publishMetric ("${arch}/${systems[i]}/release/junit-Results.xml")
    }
  }
}

def publishAdvancedMetrics (system, arch)
{
  fileOperations ([fileCopyOperation (includes: "${arch}/${system}/src/c/*.c", targetLocation: 'src/c/', flattenFiles: true),
    fileCopyOperation (includes: "${arch}/${system}/include/*.h", targetLocation: 'include/iot/', flattenFiles: true)])
  if ("${arch}" == 'x86_64')
  {
    publishValgrind (pattern: '**/*_vg.xml', sourceSubstitutionPaths: '/iotech-iot/src:src')
  }
  junit (testResults: "${arch}/${system}/release/junit-Results.xml")
  cobertura (coberturaReportFile: "${arch}/${system}/lcov/cobertura.xml")
  archiveArtifacts (artifacts: "${arch}/${system}/lcov/cobertura.xml")
  archiveArtifacts (artifacts: "${arch}/${system}/lcov/html/**")
  // publishCoverage (adapters: [coberturaAdapter("${arch}/${system}/lcov/cobertura.xml")], sourceFileResolver: sourceFiles('NEVER_STORE'))
  recordIssues (tools: [taskScanner (id: "Tasks-${arch}-${env.BUILD_ID}", highTags: 'FIXME', includePattern: '**/*.c', normalTags: 'TODO')])
  recordIssues (tools: [cppCheck (id: "CppCheck-${arch}-${env.BUILD_ID}", pattern: "${arch}/${system}/release/cppcheck.xml")])
  recordIssues (tools: [gcc (id: "GCC-${arch}-${env.BUILD_ID}", pattern: "${arch}/${system}/release/release.log")])
}

def publishDebs (arch)
{
  def debs_x86_64 = ['ubuntu-22.04','ubuntu-20.04','ubuntu-18.04','debian-11','debian-10','azuresphere-15','yocto-riscv']
  def debs_arm64 = ['ubuntu-22.04','ubuntu-20.04','ubuntu-18.04','debian-11','debian-10']
  def debs_arm32 = ['ubuntu-22.04','ubuntu-20.04','ubuntu-18.04','debian-11','debian-10']
  def debs_x86 = ['debian-11','debian-10']
  def deb_lists = [x86_64: debs_x86_64, arm64: debs_arm64, arm32: debs_arm32, x86: debs_x86]
  def deb_archs = [x86_64: 'amd64', arm64: 'arm64', arm32: 'armhf', x86: 'i386']
  def deb_name = ['ubuntu-22.04':'jammy','ubuntu-20.04':'focal','ubuntu-18.04':'bionic','debian-11':'bullseye','debian-10':'buster','azuresphere-15':'jammy','yocto-riscv':'jammy']
  def debs = deb_lists[arch]
  def sys = getSystemParam ()
  def archive = getArchiveParam ()

  for (int i = 0; i < debs.size(); ++i)
  {
    if ("${sys}" == "${debs[i]}" || "${sys}" == 'all')
    {
      def name = deb_name[debs[i]]
      def uploadSpec = """{"files":[
      {
        "pattern": "${arch}/${debs[i]}/release/iotech*iot*.deb",
        "target": "debian-${releaseType[archive]}/pool/${name}/",
        "props": "deb.distribution=${name};deb.component=main;deb.architecture=${deb_archs[arch]}"
      },
      {
        "pattern": "${arch}/${debs[i]}/debug/iotech*iot*.deb",
        "target": "debian-${releaseType[archive]}/pool/${name}/",
        "props": "deb.distribution=${name};deb.component=main;deb.architecture=${deb_archs[arch]}"
      }
      ]}"""
      rtUpload (serverId: 'artifactory', spec: "${uploadSpec}")
    }
  }
}

def publishApks (arch)
{
  def apks_x86_64 = ['alpine-3.17','alpine-3.16','alpine-3.15']
  def apks_arm64 = ['alpine-3.17','alpine-3.16','alpine-3.15']
  def apks_arm32 = ['alpine-3.17','alpine-3.16','alpine-3.15']
  def apks_x86 = ['alpine-3.17','alpine-3.16','alpine-3.15']
  def apk_lists = [x86_64: apks_x86_64, arm64: apks_arm64, arm32: apks_arm32, x86: apks_x86]
  def apk_archs = [x86_64: 'x86_64', arm64: 'aarch64', arm32: 'armv7', x86: 'x86']
  def host_archs = [x86_64: 'x86_64', arm64: 'aarch64', arm32: 'armv7', x86: 'x86']
  def apk_vers = ['alpine-3.17':'v3.17','alpine-3.16':'v3.16','alpine-3.15':'v3.15']
  def apk_arch = apk_archs[arch]
  def harch = host_archs[arch]
  def apks = apk_lists[arch]
  def sys = getSystemParam ()
  def repo = "alpine-${releaseType[archive]}"

  for (int i = 0; i < apks.size(); ++i)
  {
    if ("${sys}" == "${apks[i]}" || "${sys}" == 'all')
    {
      def uploadSpec = """{"files":[
      {
        "pattern": "${arch}/${apks[i]}/apks/*.apk",
        "target": "${repo}/${apk_vers[apks[i]]}/main/${apk_arch}/",
        "props": "distribution=${apks[i]};architecture=${apk_arch}"
      }
      ]}"""
      rtUpload (serverId: 'artifactory', spec: "${uploadSpec}")
    }
  }
}

def publishRpms (arch)
{
  def rpms_x86_64 = ['fedora-36','opensuse-15.4','photon-40']
  def rpms_arm64 = ['fedora-36','opensuse-15.4','photon-40']
  def rpms_arm32 = ['opensuse-15.4']
  def rpms_x86 = []
  def rpm_lists = [x86_64: rpms_x86_64, arm64: rpms_arm64, arm32: rpms_arm32, x86: rpms_x86]
  def rpm_arch = [x86_64: 'x86_64', arm64: 'aarch64', arm32: 'armhf']
  def rpms = rpm_lists[arch]
  def sys = getSystemParam ()
  def archive = getArchiveParam ()

  for (int i = 0; i < rpms.size(); ++i)
  {
    if ("${sys}" == "${rpms[i]}" || "${sys}" == 'all')
    {
      def uploadSpec = """{"files":[
      {
        "pattern": "${arch}/${rpms[i]}/release/iotech-iot*.rpm",
        "target": "rpm-${rpms[i]}-${releaseType[archive]}",
        "props": "rpm.metadata.release=${env.BUILD_ID}"
      },
      {
        "pattern": "${arch}/${rpms[i]}/debug/iotech-iot-*-dbg*.rpm",
        "target": "rpm-${rpms[i]}-${releaseType[archive]}",
        "props": "rpm.metadata.release=${env.BUILD_ID}"
      }
      ]}"""
      rtUpload (serverId: 'artifactory', spec: "${uploadSpec}")
    }
  }
}

def publishTars (arch)
{
  def tars_x86_64 = ['zephyr-2.3','clearlinux']
  def tars_arm64 = []
  def tars_arm32 = []
  def tars_x86 = []
  def tar_lists = [x86_64: tars_x86_64, arm64: tars_arm64, arm32: tars_arm32, x86: tars_x86]
  def tar_archs = [x86_64: 'x86_64', arm64: 'aarch64', arm32: 'armv7', x86: 'x86']
  def tars = tar_lists[arch]
  def sys = getSystemParam ()
  def archive = getArchiveParam ()

  for (int i = 0; i < tars.size(); ++i)
  {
    if ("${sys}" == "${tars[i]}" || "${sys}" == 'all')
    {
      def uploadSpec = """{"files":[
      {
        "pattern": "${arch}/${tars[i]}/release/iotech-iot*.tar.gz",
        "target": "generic-${releaseType[archive]}/${tars[i]}/",
        "props": "distribution=${tars[i]};architecture=${tar_archs[arch]}"
      },
      {
        "pattern": "${arch}/${tars[i]}/debug/iotech-iot-dev*.tar.gz",
        "target": "generic-${releaseType[archive]}/${tars[i]}/",
        "props": "distribution=${tars[i]};architecture=${tar_archs[arch]}"
      }
      ]}"""
      rtUpload (serverId: 'artifactory', spec: "${uploadSpec}")
    }
  }
}

def buildStages (target, systems)
{
  def nat = getNativeParam ()
  def sys = 'docker'
  if ("${nat}" == 'true')
  {
    sys = getSystemParam ()
  }
  def host = "${sys}-${target}"

  node (host)
  {
    stage ("Checkout ${target}") { checkoutStage (target)}
    stage ("Build ${target}") { buildStage (systems, target) }
    stage ("Metrics ${target}") { metricsStage (systems, target) }
    stage ("Archive ${target}") { archiveStage (target) }
  }
}

def String getSystemParam ()
{
  def ret = "${params.System}"
  if ("${ret}" == 'null')
  {
    ret = 'ubuntu-22.04'
  }
  return ret
}

def String getArchParam ()
{
  def ret = "${params.Arch}"
  if ("${ret}" == 'null')
  {
    ret = 'x86_64'
  }
  return ret
}

def String getArchiveParam ()
{
  def ret = "${params.Archive}"
  if ("${ret}" == 'null')
  {
    ret = 'None'
  }
  return ret
}

def String getTargetParam ()
{
  def ret = "${params.Target}"
  if ("${ret}" == 'null')
  {
    ret = 'None'
  }
  return ret
}

def String getNativeParam ()
{
  def ret = "${params.Native}"
  if ("${ret}" == 'null')
  {
    ret = 'false'
  }
  return ret
}

def String getSonarQubeParam ()
{
  def ret = "${params.SonarQube}"
  if ("${ret}" == 'null')
  {
    ret = 'false'
  }
  return ret
}

buildMap = [:]
for (t in targets)
{
  def target = t
  def sys = getSystemParam ()
  def arch = getArchParam ()
  def systems = arch_system_map["${target}"]

  if (("${arch}" == target || "${arch}" == 'all') && ("${sys}" == 'all' || systems.count ("${sys}") != 0))
  {
    buildMap[target] = { buildStages (target, systems) }
  }
}
buildMap.failFast = false

pipeline
{
  agent none
  options
  {
    buildDiscarder (logRotator (numToKeepStr: '10'))
    timeout (time: 90, unit: 'MINUTES')
  }
  triggers
  {
    issueCommentTrigger ('.*recheck.*')
  }
  parameters
  {
    choice (name: 'Archive', choices: ['None','Development','Release'], description: 'Build Archive Type')
    choice (name: 'System', choices: ['ubuntu-22.04','ubuntu-20.04','ubuntu-18.04','alpine-3.17','alpine-3.16','alpine-3.15','debian-11','debian-10','fedora-36','opensuse-15.4','photon-40','zephyr-2.3','clearlinux','azuresphere-15','yocto-riscv','all'], description: 'System to Build')
    choice (name: 'Arch', choices: ['x86_64','x86','arm64','arm32','all'], description: 'Build Host Architecture')
    choice (name: 'Target', choices: ['None','frdm_k64f','qemu_x86','riscv64-oe','riscv32-oe','acrn','all'], description: 'Target System')
    booleanParam (name: 'Native', defaultValue: false, description: 'Build on host not in container')
    booleanParam (name: 'SonarQube', defaultValue: false, description: 'Run SonarQube (only for ubuntu-22.04 x86_64)')
  }
  stages { stage ('All') { steps { script { parallel buildMap }}}}
}
